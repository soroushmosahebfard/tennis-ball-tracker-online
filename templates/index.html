<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Live Tennis-Ball Tracker (Client Side)</title>
  <style>
    body { background:#111; color:#fff; text-align:center; }
    canvas { border:4px solid #4caf50; margin-top:20px; }
  </style>
</head>
<body>
  <h1>ðŸŽ¾ Live Tennis-Ball + Corner Tracker</h1>
  <video id="video" width="640" height="480" autoplay muted playsinline style="display:none"></video>
  <canvas id="canvas" width="1280" height="480"></canvas>

  <!-- Load OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" 
          onload="onOpenCvReady();"></script>
  <script>
    let video = document.getElementById('video');
    let canvas = document.getElementById('canvas');
    let ctx    = canvas.getContext('2d');

    function onOpenCvReady() {
      // 1) start camera
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => { video.srcObject = stream; })
        .catch(err => console.error(err));

      video.addEventListener('play', processFrame);
    }

    function processFrame() {
      if (video.paused || video.ended) return;
      // draw raw video on left half
      ctx.drawImage(video, 0, 0, 640, 480);

      // grab that image data
      let src = cv.imread(canvas, {x:0,y:0,w:640,h:480});
      let proc = src.clone();

      // --- tennis-ball detection (yellow) ---
      let blurred = new cv.Mat();
      cv.GaussianBlur(proc, blurred, new cv.Size(11,11), 0);
      let hsv = new cv.Mat();
      cv.cvtColor(blurred, hsv, cv.COLOR_BGR2HSV);
      let lower = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [20,100,100,0]);
      let upper = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [40,255,255,255]);
      let mask = new cv.Mat();
      cv.inRange(hsv, lower, upper, mask);
      // clean up
      cv.erode(mask, mask, new cv.Mat(), new cv.Point(-1,-1), 2);
      cv.dilate(mask, mask, new cv.Mat(), new cv.Point(-1,-1), 2);

      // find contours
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      if (contours.size() > 0) {
        // pick largest
        let maxIdx = 0, maxArea = 0;
        for (let i=0; i<contours.size(); i++) {
          let area = cv.contourArea(contours.get(i));
          if (area > maxArea) { maxArea = area; maxIdx = i; }
        }
        let circle = cv.minEnclosingCircle(contours.get(maxIdx));
        let center = circle.center, radius = circle.radius;
        if (radius > 10) {
          cv.circle(proc, center, radius, [0,255,255,255], 2);
        }
      }

      // --- Shi-Tomasi corners ---
      let gray = new cv.Mat();
      cv.cvtColor(proc, gray, cv.COLOR_BGR2GRAY);
      let corners = new cv.Mat();
      cv.goodFeaturesToTrack(gray, corners, 50, 0.01, 10);
      for (let i=0; i<corners.rows; i++) {
        let x = corners.data32F[i*2], y = corners.data32F[i*2+1];
        cv.circle(proc, new cv.Point(x,y), 3, [255,0,0,255], -1);
      }

      // draw processed on right half
      cv.imshow(canvas, proc, {dx:640, dy:0});

      // cleanup
      src.delete(); proc.delete(); blurred.delete(); hsv.delete();
      lower.delete(); upper.delete(); mask.delete();
      contours.delete(); hierarchy.delete(); gray.delete(); corners.delete();

      // schedule next frame
      requestAnimationFrame(processFrame);
    }
  </script>
</body>
</html>
